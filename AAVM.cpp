#include "AAVM.h"
#include "AAB2F.h"
#include "stack.h"

AAVM* AANewVM() {
	return new AAVM;
}

AAVM::AAVM() {

	m_compiler = new AAC;
	m_parser = new AAP;
	m_outStream = 0;

}

void AAVM::Release() {

	// Delete compiler
	delete m_compiler;
	m_compiler = 0;

	// Delete parser
	m_parser->Release();
	delete m_parser;
	m_parser = 0;

}

AAC_Out AAVM::CompileExpressionToFile(std::wstring input, std::wstring outputfile) {

	// Generated AST from input
	AA_AST* tree = m_parser->Parse(input);

	// Generated bytecode
	AAC_Out bytecode = m_compiler->CompileFromAST(tree);

	// Dump bytecode
	aa::dump_bytecode(outputfile, bytecode);

	// Aslo return bytecode (so we can execute it directly)
	return bytecode;

}

AAC_Out AAVM::CompileFileToFile(std::wstring fileIn, std::wstring fileOut) { // TODO: Implement

	// Generated AST from input
	AA_AST* tree = m_parser->Parse(L"");

	// Generated bytecode
	AAC_Out bytecode = m_compiler->CompileFromAST(tree);

	return bytecode;

}

void AAVM::RunFile(std::wstring file) {



}

void AAVM::RunExpression(std::wstring input) {

	// Generated AST from input
	AA_AST* tree = m_parser->Parse(input);

	// Generated bytecode
	AAC_Out bytecode = m_compiler->CompileFromAST(tree);

	// Execute the bytecode
	Execute(bytecode.bytes, bytecode.length);

}

void AAVM::Execute(AAC_Out bytecode) {
	this->Execute(bytecode.bytes, bytecode.length);
}

void AAVM::Execute(unsigned char* bytes, unsigned long long len) {

	// The operation count
	int opCount;

	// Operation list, variable enviornment, and constants table
	AAO* ops = 0; AA_Literal* constants = 0; AAVarEnv* venv = 0;

	// Create the execution environment
	CreateExecutionEnvironment(bytes, len, constants, venv, ops, opCount);

	// Run
	Run(constants, venv, ops, opCount);

}

void AAVM::Run(AA_Literal* cenv, AAVarEnv* venv, AAO* ops, int opCount) {

	int opPointer = 0;
	aa::stack<AAVal> stack;

	while (opPointer < opCount) {

		switch (ops[opPointer].op) {
		case AAByteCode::PUSHC:
			stack.Push(cenv[ops[opPointer].args[0]]);
			opPointer++;
			break;
		case AAByteCode::ADD: {
			AA_Literal rhs = stack.Pop().litVal;
			AA_Literal lhs = stack.Pop().litVal;
			AA_Literal r = lhs + rhs;
			stack.Push(r);
			opPointer++;
			break;
		}
		case AAByteCode::SUB: {
			AA_Literal rhs = stack.Pop().litVal;
			AA_Literal lhs = stack.Pop().litVal;
			AA_Literal r = lhs - rhs;
			stack.Push(r);
			opPointer++;
			break;
		}
		case AAByteCode::MUL: {
			AA_Literal rhs = stack.Pop().litVal;
			AA_Literal lhs = stack.Pop().litVal;
			AA_Literal r = lhs * rhs;
			stack.Push(r);
			opPointer++;
			break;
		}
		case AAByteCode::DIV: {
			AA_Literal rhs = stack.Pop().litVal;
			AA_Literal lhs = stack.Pop().litVal;
			stack.Push(lhs / rhs);
			opPointer++;
			break;
		}
		case AAByteCode::MOD: {
			AA_Literal rhs = stack.Pop().litVal;
			AA_Literal lhs = stack.Pop().litVal;
			stack.Push(lhs % rhs);
			opPointer++;
			break;
		}
		case AAByteCode::NNEG: {
			stack.Push(-stack.Pop().litVal);
			opPointer++;
			break;
		}
		case AAByteCode::GETVAR: {
			stack.Push(venv->GetVariable(ops[opPointer].args[0]));
			opPointer++;
			break;
		}
		case AAByteCode::SETVAR: {
			AA_Literal rhs = stack.Pop().litVal;
			venv->SetVariable(ops[opPointer].args[0], rhs);
			opPointer++;
			break;
		}
		case AAByteCode::NOP:
		default:
			opPointer++;
			break;
		}

	}

	if (stack.Size() == 1) {
		if (m_outStream) {
			m_outStream->operator<<(stack.Pop().litVal.lit.i.val);
			m_outStream->write("\n", 1);
		}
	}

}

void AAVM::CreateExecutionEnvironment(unsigned char* bytes, unsigned long long len, AA_Literal*& constants, AAVarEnv*& varEnv, AAO*& oplist, int& opCount) {

	unsigned int offset;
	constants = LoadConstsTable(bytes, len, offset);
	varEnv = LoadVariableEnviornment(bytes, len, offset);
	oplist = LoadOpSequence(bytes + offset, len, opCount);

}

AA_Literal* AAVM::LoadConstsTable(unsigned char* bytes, unsigned long long len, unsigned int& offset) {

	int count = 0;
	memcpy(&count, bytes, 4);

	offset = 4;
	AA_Literal* table = new AA_Literal[count];

	for (int i = 0; i < count; i++) {

		unsigned char type;
		memcpy(&type, bytes + offset, 1);

		offset++;
		table[i].tp = (AALiteralType)type;

		switch (table[i].tp) {
		case AALiteralType::Int:
			memcpy(&table[i].lit.i.val, bytes + offset, 4);
			offset += 4;
			break;
		case AALiteralType::String:
			break;
		case AALiteralType::Float:
			break;
		case AALiteralType::Boolean:
			break;
		default:
			break;
		}

	}

	return table;

}

AAO* AAVM::LoadOpSequence(unsigned char* bytes, unsigned long long len, int& count) {

	unsigned long long offset = 0;

	count = 0;
	memcpy(&count, bytes, 4);
	offset += 4;

	AAO* opSequence = new AAO[count];

	for (int i = 0; i < count; i++) {

		unsigned char opchar;
		memcpy(&opchar, bytes + offset, 1);
		offset += 1;

		opSequence[i].op = (AAByteCode)opchar;

		switch (opSequence[i].op) {
		case AAByteCode::PUSHC:
		case AAByteCode::GETVAR:
		case AAByteCode::SETVAR:
			opSequence[i].args = new int[1];
			memcpy(opSequence[i].args, bytes + offset, 4);
			offset += 4;
			break;
		case AAByteCode::NOP:
		case AAByteCode::ADD:
		case AAByteCode::SUB:
		case AAByteCode::MOD:
		case AAByteCode::MUL:
		case AAByteCode::DIV:
		case AAByteCode::NNEG:
			opSequence[i].args = 0;
			break;
		default:
			break;
		}

	}

	return opSequence;

}

AAVarEnv* AAVM::LoadVariableEnviornment(unsigned char* bytes, unsigned long long length, unsigned int& offset) {

	int count = 0;
	memcpy(&count, bytes + offset, 4);
	offset += 4;

	AAVarEnv* venv = new AAVarEnv;

	for (int i = 0; i < count; i++) {

		int len = 0;
		memcpy(&len, bytes + offset, 4);
		offset += 4;

		venv->DeclareVariable(len);

		/*
		wchar_t* identifier = new wchar_t[len + 1];
		wmemset(identifier, '\0', len + 1);

		memcpy(identifier, bytes + offset, len * 2);
		offset += len * 2;

		venv->DeclareVariable(std::wstring(identifier));

		delete[] identifier;
		*/
	}

	return venv;

}
