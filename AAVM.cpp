#include "AAVM.h"
#include "AAB2F.h"
#include "astring.h"
#include "AAString.h"
#include "AAConsole.h"

AAVM* AAVM::CreateNewVM(bool logExecuteTime, bool logCompiler, bool logTopStack) {
	AAVM* vm = new AAVM();
	vm->m_logCompileMessages = logCompiler;
	vm->m_logExecTime = logExecuteTime;
	vm->m_logTopOfStackAfterExec = logTopStack;
	vm->LoadStandardLibrary();
	return vm;
}

AAVM::AAVM() {

	m_compiler = new AAC;

	if (m_compiler) {
		m_compiler->SetupCompiler();
	}

	m_parser = new AAP;
	m_outStream = 0;

	m_startCompile = 0;

	m_logTopOfStackAfterExec = false;
	m_logCompileMessages = false;
	m_logExecTime = false;

}

void AAVM::Release() {

	// Delete compiler
	delete m_compiler;
	m_compiler = 0;

	// Delete parser
	m_parser->Release();
	delete m_parser;
	m_parser = 0;

}

AAVal AAVM::CompileAndRunExpression(std::wstring input) {
	return this->CompileAndRunExpression(input, L"", L"");
}

AAVal AAVM::CompileAndRunExpression(std::wstring input, std::wstring binaryoutputfile, std::wstring formattedoutputfile) {

	// Start compile clock
	m_startCompile = clock();

	// Parse the input
	AAP_ParseResult result = m_parser->Parse(input);

	// Return full result of compile and run
	return this->CompileAndRun(result, binaryoutputfile, formattedoutputfile);

}

AAVal AAVM::CompileAndRunFile(std::wstring sourcefile, std::wstring binaryoutputfile, std::wstring formattedoutputfile) {
	
	// Start compile clock
	m_startCompile = clock();

	// Parse the input
	AAP_ParseResult result = m_parser->Parse(std::wifstream(sourcefile));

	// Return full result of compile and run
	return this->CompileAndRun(result, binaryoutputfile, formattedoutputfile);

}

AAC_Out AAVM::CompileFileToFile(std::wstring fileIn, std::wstring fileOut) { // TODO: Implement

	// Generated AST from input
	//AA_AST* tree = m_parser->Parse(L"");

	// Generated bytecode
	AAC_Out bytecode; //= m_compiler->CompileFromAST(0);

	return bytecode;

}

void AAVM::RunFile(std::wstring file) {



}

void AAVM::RunExpression(std::wstring input) {

	// Generated AST from input
	//AA_AST* tree = m_parser->Parse(input);

	// Generated bytecode
	AAC_Out bytecode;// = m_compiler->CompileFromAST(0);

	// Execute the bytecode
	Execute(bytecode.bytes, bytecode.length);

}

AAVal AAVM::CompileAndRunFile(std::wstring sourcefile) {
	return this->CompileAndRunFile(sourcefile, L"", L"");
}

AAVal AAVM::CompileAndRun(AAP_ParseResult result, std::wstring binaryoutputfile, std::wstring formattedoutputfile) {

	// The the parser succeed?
	if (result.success) {

		// Set compiler output file
		m_compiler->SetOpListFile(formattedoutputfile);

		// Compile all procedures into bytecode
		AAC_CompileResult compileResult = m_compiler->CompileFromAbstractSyntaxTrees(result.result);

		// Log compile time and other messages
		this->StopAndLogCompile();

		// Did we compile without error?
		if (COMPILE_SUCESS(compileResult)) {

			// Only dump bytecode if a filepath is specified
			if (binaryoutputfile != L"") {

				// Dump bytecode
				aa::dump_bytecode(binaryoutputfile, compileResult.result);

			}

			// Cleanup trees
			m_parser->ClearTrees(result.result);

			// Execute the bytecode
			return this->Execute(compileResult.result);

		} else {

			// Write compiler error
			this->WriteCompilerError(compileResult.firstMsg);

			// Return null
			return AAVal::Null;

		}

	} else {

		// Write syntax error
		this->WriteSyntaxError(result.firstMsg);

		// Return null
		return AAVal::Null;

	}

}

AAVal AAVM::Execute(AAC_Out bytecode) {
	return this->Execute(bytecode.bytes, bytecode.length);
}

AAVal AAVM::Execute(unsigned char* bytes, unsigned long long len) {

	// Load program so we can execute it
	AAProgram* pProg = new AAProgram;
	if (pProg->LoadProgram(bytes, len)) {

		// Run the program
		return this->Run(pProg);

	} else {

		// Return AAVal Error
		return AAVal(L"");

	}

}

AAVal AAVM::Run(AAProgram* pProg) {

	// Get entry point
	int entryPoint = pProg->GetEntryPoint();

	// Log start time
	clock_t s = clock();

	// Run the program from entry point
	AAVal v = this->Run(pProg->m_procedures, entryPoint);

	// Should we log execution?
	if (m_logExecTime) {

		// Print execution time
		printf("Execute time: %fs\n", (float)(clock() - s) / CLOCKS_PER_SEC);

	}

	return v;

}

#define AAVM_VENV execp.venv
#define AAVM_OPI execp.opPointer
#define AAVM_PROC execp.procPointer

#define AAVM_CURRENTOP procedure[AAVM_PROC].opSequence[AAVM_OPI].op
#define AAVM_GetArgument(i) procedure[AAVM_PROC].opSequence[AAVM_OPI].args[i]

#define AAVM_ThrowRuntimeErr(exc, msg) this->WriteRuntimeError(AAVM_RuntimeError(exc, (msg).c_str(), execp, callstack)); return AAVal::Null;

AAVal AAVM::Run(AAProgram::Procedure* procedure, int entry) {

	aa::stack<AAVal> stack;
	aa::stack<AARuntimeEnvironment> callstack;

	AARuntimeEnvironment execp;
	execp.opPointer = 0;
	execp.procPointer = entry;
	execp.venv = procedure[entry].venv->CloneSelf();

	while (AAVM_OPI < procedure[AAVM_PROC].opCount) {
		switch (AAVM_CURRENTOP) {
		case AAByteCode::ADD:
		case AAByteCode::CMPE:
		case AAByteCode::CMPNE:
		case AAByteCode::DIV:
		case AAByteCode::GE:
		case AAByteCode::GEQ:
		case AAByteCode::LE:
		case AAByteCode::LEQ:
		case AAByteCode::MOD:
		case AAByteCode::MUL:
		case AAByteCode::SUB:
		{
			AA_Literal rhs = stack.Pop().litVal;
			AA_Literal lhs = stack.Pop().litVal;
			stack.Push(BinaryOperation(AAVM_CURRENTOP, lhs, rhs));
			AAVM_OPI++;
			break;
		}
		case AAByteCode::PUSHC: {
			int p = AAVM_GetArgument(0);
			stack.Push(procedure[AAVM_PROC].constTable[p]);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::NNEG: {
			stack.Push(-stack.Pop().litVal);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::LNEG: {
			stack.Push(!stack.Pop().litVal);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::GETVAR: {
			stack.Push(AAVM_VENV->GetVariable(AAVM_GetArgument(0)));
			AAVM_OPI++;
			break;
		}
		case AAByteCode::SETVAR: {
			AAVal rhs = stack.Pop();
			AAVM_VENV->SetVariable(AAVM_GetArgument(0), rhs);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::CALL: {

			int callProc = AAVM_GetArgument(0);
			int argCount = AAVM_GetArgument(1);

			if (callProc == -1) {
				AAVM_ThrowRuntimeErr("FatalCompileError", "Call index " + std::to_string(callProc) + " is out of range!");
			}

			aa::stack<AAVal> args;
			for (int i = 0; i < argCount; i++) {
				args.Push(stack.Pop());
			}

			AAVM_OPI++;
			callstack.Push(execp);

			AAVM_VENV = procedure[callProc].venv->CloneSelf();
			AAVM_PROC = callProc;
			AAVM_OPI = 0;

			while (args.Size() > 0) {
				stack.Push(args.Pop());
			}

			break;
		}
		case AAByteCode::VMCALL: {
			
			// Get function
			int callProc = AAVM_GetArgument(0);
			int argCount = AAVM_GetArgument(1);
			
			// Collect arguments
			aa::stack<AAVal> args;
			for (int i = 0; i < argCount; i++) {
				args.Push(stack.Pop());
			}

			// Call the native function
			this->m_cppfunctions[callProc].fPtr(this, args, stack);

			// Goto next cmd
			AAVM_OPI++;

			break;
		}
		case AAByteCode::RET: {
			int retCount = AAVM_GetArgument(0);
			aa::stack<AAVal> returnValues;
			for (int i = 0; i < retCount; i++) {
				returnValues.Push(stack.Pop());
			}

			if (callstack.Size() > 0) {
				delete execp.venv;
				execp = callstack.Pop();
			} else {
				AAVM_ThrowRuntimeErr("CallstackCorrupted", std::string("The callstack was unexpectedly corrupted"));
			}

			for (int i = 0; i < retCount; i++) {
				stack.Push(returnValues.Pop());
			}

			break;
		}
		case AAByteCode::JMPF: {
			if (stack.Pop().litVal.lit.b.val) {
				AAVM_OPI++;
			} else {
				AAVM_OPI += 1 + AAVM_GetArgument(0); // jump to next (if-else or else) or next statement after block
			}
			break;
		}
		case AAByteCode::JMPT: {
			if (!stack.Pop().litVal.lit.b.val) {
				AAVM_OPI++;
			} else {
				AAVM_OPI += 1 + AAVM_GetArgument(0); // jump to next (if-else or else) or next statement after block
			}
			break;
		}
		case AAByteCode::JMP: {
			AAVM_OPI += 1 + AAVM_GetArgument(0);
			break;
		}
		case AAByteCode::HALLOC: {
			int allocsz = AAVM_GetArgument(0);
			AAVal allocobj = AAVal(AllocAAO((size_t)allocsz));
			stack.Push(allocobj);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::GETFIELD: {
			AAVal o = stack.Pop();
			stack.Push(o.obj->values[AAVM_GetArgument(0)]);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::SETFIELD: {
			AAVal rhs = stack.Pop();
			AAVal o = stack.Pop();
			o.obj->values[AAVM_GetArgument(0)] = rhs;
			AAVM_OPI++;
			break;
		}
		case AAByteCode::GETELEM: {
			int i = stack.Pop().litVal.lit.i.val;
			AAVal e = stack.Pop();
			if (i >= 0 && i < e.obj->valCount) {
				stack.Push(e.obj->values[i]);
			} else {
				AAVM_ThrowRuntimeErr("IndexOutOfRange", "Index " + std::to_string(i) + " is out of range!");
			}
			AAVM_OPI++;
			break;
		}
		case AAByteCode::SETELEM: {
			AAVal v = stack.Pop();
			int i = stack.Pop().litVal.lit.i.val;
			AAVal e = stack.Pop();
			if (i >= 0 && i < e.obj->valCount) {
				e.obj->values[i] = v;
			} else {
				AAVM_ThrowRuntimeErr("IndexOutOfRange", "Index " + std::to_string(i) + " is out of range!");
			}
			AAVM_OPI++;
			break;
		}
		case AAByteCode::NOP:
		default:
			AAVM_OPI++;
			break;
		}

	}

	// Return whatever's on top of the stack
	return this->ReportStack(stack);

}

AAVal AAVM::BinaryOperation(AAByteCode op, AA_Literal lhs, AA_Literal rhs) {
	switch (op) {
	case AAByteCode::ADD: {
		return lhs + rhs;
	}
	case AAByteCode::SUB: {
		return lhs - rhs;
	}
	case AAByteCode::MUL: {
		return lhs * rhs;
	}
	case AAByteCode::DIV: {
		return lhs / rhs;
	}
	case AAByteCode::MOD: {
		return lhs % rhs;
	}
	case AAByteCode::CMPE: {
		return AAVal(lhs == rhs);
	}
	case AAByteCode::CMPNE: {
		return AAVal(lhs != rhs);
	}
	case AAByteCode::LE: {
		return AAVal(lhs < rhs);
	}
	case AAByteCode::LEQ: {
		return AAVal(lhs <= rhs);
	}
	case AAByteCode::GE: {
		return AAVal(lhs > rhs);
	}
	case AAByteCode::GEQ: {
		return AAVal(lhs >= rhs);
	}
	default:
		return AAVal(0);
	}
}

AAVal AAVM::ReportStack(aa::stack<AAVal> stack) {

	if (stack.Size() == 1) {
		AAVal v = stack.Pop();
		if (m_outStream && m_logTopOfStackAfterExec) {
			std::wstring ws = v.ToString();
			m_outStream->write(string_cast(ws).c_str(), ws.length());
			m_outStream->write("\n", 1);
		}
		return v;
	} else {
		return AAVal::Null;
	}

}

void AAVM::WriteCompilerError(AAC_CompileErrorMessage errMsg) {

	// Do we have a valid message?
	if (errMsg.errorMsg) {

		// Format the compile error message
		std::string compileErrMsg = "Failed to compile, [C" + std::to_string(errMsg.errorType) + "] -> '" + std::string(errMsg.errorMsg)
			+ "' on line " + std::to_string(errMsg.errorSource.line) + ", column " + std::to_string(errMsg.errorSource.column) + "\n";

		// Write error message
		this->WriteMsg(compileErrMsg.c_str());

	}

}

void AAVM::WriteSyntaxError(AAP_SyntaxErrorMessage errMsg) {

	// Do we have a valid message?
	if (errMsg.errorMsg) {

		// Format the syntax error message
		std::string syntaxErrMsg = "Syntax error, [S" + std::to_string(errMsg.errorType) + "] -> '" + std::string(errMsg.errorMsg)
			+ "' on line " + std::to_string(errMsg.errorSource.line) + ", column " + std::to_string(errMsg.errorSource.column) + "\n";

		// Write syntax message
		this->WriteMsg(syntaxErrMsg.c_str());

	}

}

void AAVM::WriteRuntimeError(AAVM_RuntimeError err) {

	// Make sure there's a valid error message
	if (err.errMsg) {

		// Format runtime message
		std::string runtimeErrMsg = "Runtime exception, [" + std::string(err.errName) + "] -> '" + std::string(err.errMsg) + "'\n";

		// Write message
		this->WriteMsg(runtimeErrMsg.c_str());

	}

}

void AAVM::WriteMsg(const char* msg) {

	// Make sure there's a valid stream to write to
	if (m_outStream) {

		// Write error message
		m_outStream->write(msg, strlen(msg));

	}

}

int AAVM::RegisterFunction(AACSingleFunction funcPtr, AAFuncSignature& funcSig, bool isClassMethod) {

	// Fetch proc ID
	int procId = (int)m_cppfunctions.size();

	// Create function signature
	funcSig.name = funcPtr.name;
	funcSig.returnType = funcPtr.returnType;
	funcSig.parameters = funcPtr.params;
	funcSig.isVMFunc = true;
	funcSig.isClassMethod = isClassMethod;
	funcSig.accessModifier = AAAccessModifier::PUBLIC;
	funcSig.procID = procId;

	// Push functions
	m_cppfunctions.push_back(funcPtr);

	// Add VM function so the compiler can recognize it
	m_compiler->AddVMFunction(funcSig);

	// Return the proc ID
	return procId;

}

int AAVM::RegisterFunction(AACSingleFunction funcPtr) {

	AAFuncSignature dcSig;
	return this->RegisterFunction(funcPtr, dcSig);

}

void AAVM::RegisterClass(std::wstring typeName, AACClass cClass) {

	AAClassSignature cc;
	cc.name = typeName;

	for (auto& func : cClass.classMethods) {
		
		// Update function name
		func.name = cc.name + L"::" + func.name;

		// Check if it's a constructor
		bool isCtor = func.name == cc.name + L"::.ctor";;

		// Function signature
		AAFuncSignature sig;

		// Because it's a class method we always push the 'this' identifier -> Note, should not be the case if static (but not implemented yet)
		func.params.insert(func.params.begin(), AAFuncParam(L"string", L"this"));

		// Register the funcion and get the VMCall procID
		this->RegisterFunction(func, sig, true);
		sig.isClassCtor = true;

		// Add method to class
		cc.methods.Add(sig);

	}

	for (auto& op : cClass.classOperators) {

		// Get the actual function
		AACSingleFunction func = op.funcPtr;

		// Update function name
		func.name = cc.name + L"::" + func.name;

		// Function signature
		AAFuncSignature sig;

		// Because it's a class method we always push the 'this' identifier -> Note, should not be the case if static (but not implemented yet)
		func.params.insert(func.params.begin(), AAFuncParam(L"string", L"this"));

		// Register the funcion and get the VMCall procID
		int procID = this->RegisterFunction(func, sig, true);

		// Add method to operators list
		cc.operators.Add(AAClassOperatorSignature(op.operatorToOverride, sig));

	}

	for (auto& field : cClass.classFields) {

		AAClassFieldSignature ccf;
		ccf.fieldID = (int)cc.fields.Size();
		ccf.accessModifier = AAAccessModifier::PUBLIC;
		ccf.type = field.fieldtype;
		ccf.name = field.fieldname;

		cc.fields.Add(ccf);

	}

	// Update class size
	cc.classByteSz = m_compiler->GetClassCompilerInstance()->CalculateMemoryUse(cc);

	// Add the VM class
	m_compiler->AddVMClass(cc);

}

void AAVM::LoadStandardLibrary() {

	// Register println
	this->RegisterFunction(AACSingleFunction(L"println", &AAConsole_PrintLn, L"void", 1, AAFuncParam(L"Any", L"obj")));

	AACClass stringClass;
	stringClass.classMethods.push_back(AACSingleFunction(L"length", &AAString_Length, L"int", 0));
	stringClass.classOperators.push_back(AACClassOperator(L"+", AACSingleFunction(L"concat", &AAString_Concat, L"string", 1, AAFuncParam(L"string", L"_x"))));

	this->RegisterClass(L"string", stringClass);

}

void AAVM::StopAndLogCompile() {

	// If we should log stuff, we do it now
	if (m_logCompileMessages) {
		printf("Compile time: %fs\n", (float)(clock() - m_startCompile) / CLOCKS_PER_SEC);
	}

}
