#include "AAVM.h"
#include "AAB2F.h"
#include "astring.h"
#include "AAString.h"
#include "AAConsole.h"
#include "AAstdiolib.h"
#include "AAMemoryStore.h"

AAVM* AAVM::CreateNewVM(bool logExecuteTime, bool logCompiler, bool logTopStack) {
	AAVM* vm = new AAVM();
	vm->m_logCompileMessages = logCompiler;
	vm->m_logExecTime = logExecuteTime;
	vm->m_logTopOfStackAfterExec = logTopStack;
	vm->LoadStandardLibrary();
	return vm;
}

AAVM::AAVM() {

	m_compiler = new AAC;

	if (m_compiler) {
		m_compiler->SetupCompiler();
	}

	m_parser = new AAP;
	m_outStream = 0;

	m_startCompile = 0;

	m_heapMemory = 0;

	m_logTopOfStackAfterExec = false;
	m_logCompileMessages = false;
	m_logExecTime = false;

	// Nothing has been run yet, thus we couldn't have a runtime error
	m_hasRuntimeError = false;

}

void AAVM::Release() {

	// Delete compiler
	delete m_compiler;
	m_compiler = 0;

	// Delete parser
	m_parser->Release();
	delete m_parser;
	m_parser = 0;

}

AAVal AAVM::CompileAndRunExpression(std::wstring input) {
	return this->CompileAndRunExpression(input, L"", L"");
}

AAVal AAVM::CompileAndRunExpression(std::wstring input, std::wstring binaryoutputfile, std::wstring formattedoutputfile) {

	// Start compile clock
	m_startCompile = clock();

	// Parse the input
	AAP_ParseResult result = m_parser->Parse(input);

	// Return full result of compile and run
	return this->CompileAndRun(result, binaryoutputfile, formattedoutputfile);

}

AAVal AAVM::CompileAndRunFile(std::wstring sourcefile, std::wstring binaryoutputfile, std::wstring formattedoutputfile) {
	
	// Start compile clock
	m_startCompile = clock();

	// Parse the input
	AAP_ParseResult result = m_parser->Parse(std::wifstream(sourcefile));

	// Return full result of compile and run
	return this->CompileAndRun(result, binaryoutputfile, formattedoutputfile);

}

AAC_Out AAVM::CompileFileToFile(std::wstring fileIn, std::wstring fileOut) { // TODO: Implement

	// Generated AST from input
	//AA_AST* tree = m_parser->Parse(L"");

	// Generated bytecode
	AAC_Out bytecode; //= m_compiler->CompileFromAST(0);

	return bytecode;

}

void AAVM::RunFile(std::wstring file) {



}

void AAVM::RunExpression(std::wstring input) {

	// Generated AST from input
	//AA_AST* tree = m_parser->Parse(input);

	// Generated bytecode
	AAC_Out bytecode;// = m_compiler->CompileFromAST(0);

	// Execute the bytecode
	Execute(bytecode.bytes, bytecode.length);

}

AAVal AAVM::CompileAndRunFile(std::wstring sourcefile) {
	return this->CompileAndRunFile(sourcefile, L"", L"");
}

AAVal AAVM::CompileAndRun(AAP_ParseResult result, std::wstring binaryoutputfile, std::wstring formattedoutputfile) {

	// The the parser succeed?
	if (result.success) {

		// Set compiler output file
		m_compiler->SetOpListFile(formattedoutputfile);

		// Compile all procedures into bytecode
		AAC_CompileResult compileResult = m_compiler->CompileFromAbstractSyntaxTrees(result.result);

		// Log compile time and other messages
		this->StopAndLogCompile();

		// Did we compile without error?
		if (COMPILE_SUCESS(compileResult)) {

			// Only dump bytecode if a filepath is specified
			if (binaryoutputfile != L"") {

				// Dump bytecode
				aa::dump_bytecode(binaryoutputfile, compileResult.result);

			}

			// Cleanup trees
			m_parser->ClearTrees(result.result);

			// Update last compile result
			m_lastCompileResult = compileResult;

			// Execute the bytecode
			return this->Execute(compileResult.result);

		} else {

			// Write compiler error
			this->WriteCompilerError(compileResult.firstMsg);

			// Return null
			return AAVal::Null;

		}

	} else {

		// Write syntax error
		this->WriteSyntaxError(result.firstMsg);

		// Return null
		return AAVal::Null;

	}

}

AAVal AAVM::Execute(AAC_Out bytecode) {
	return this->Execute(bytecode.bytes, bytecode.length);
}

AAVal AAVM::Execute(unsigned char* bytes, unsigned long long len) {

	// Load program so we can execute it
	AAProgram* pProg = new AAProgram;
	if (pProg->LoadProgram(bytes, len)) {

		// Run the program
		return this->Run(pProg);

	} else {

		// Return AAVal Error
		return AAVal(L"");

	}

}

AAVal AAVM::Run(AAProgram* pProg) {

	// Clear last runtime flag
	m_hasRuntimeError = false;

	// Get entry point
	int entryPoint = pProg->GetEntryPoint();

	// Log start time
	clock_t s = clock();

	// Run the program from entry point
	AAVal v = this->Run(pProg->m_procedures, entryPoint);

	// Should we log execution?
	if (m_logExecTime) {

		// Print execution time
		printf("Execute time: %fs\n", (float)(clock() - s) / CLOCKS_PER_SEC);

	}

	return v;

}

#define AAVM_VENV execp.venv
#define AAVM_OPI execp.opPointer
#define AAVM_PROC execp.procPointer

#define AAVM_CURRENTOP procedure[AAVM_PROC].opSequence[AAVM_OPI].op
#define AAVM_GetArgument(i) procedure[AAVM_PROC].opSequence[AAVM_OPI].args[i]

#define AAVM_ThrowRuntimeErr(exc, msg) this->WriteRuntimeError(AAVM_RuntimeError(exc, (msg).c_str(), execp, callstack)); return AAVal::Null;

AAVal AAVM::Run(AAProgram::Procedure* procedure, int entry) {

	aa::stack<AAVal> stack;
	aa::stack<AARuntimeEnvironment> callstack;

	// Represents the VM's heap memory (We allocate this on the heap as well). We do this every time a program is executed
	m_heapMemory = new AAMemoryStore(256);

	AARuntimeEnvironment execp;
	execp.opPointer = 0;
	execp.procPointer = entry;
	execp.venv = procedure[entry].venv->CloneSelf();

	while (AAVM_OPI < procedure[AAVM_PROC].opCount) {
		switch (AAVM_CURRENTOP) {
		case AAByteCode::ADD:
		case AAByteCode::CMPE:
		case AAByteCode::CMPNE:
		case AAByteCode::DIV:
		case AAByteCode::GE:
		case AAByteCode::GEQ:
		case AAByteCode::LE:
		case AAByteCode::LEQ:
		case AAByteCode::MOD:
		case AAByteCode::MUL:
		case AAByteCode::SUB:
		{
			AA_Literal rhs = stack.Pop().litVal;
			AA_Literal lhs = stack.Pop().litVal;
			stack.Push(BinaryOperation(AAVM_CURRENTOP, lhs, rhs));
			AAVM_OPI++;
			break;
		}
		case AAByteCode::PUSHC: {
			int p = AAVM_GetArgument(0);
			stack.Push(procedure[AAVM_PROC].constTable[p]);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::NNEG: {
			stack.Push(-stack.Pop().litVal);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::LNEG: {
			stack.Push(!stack.Pop().litVal);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::GETVAR: {
			stack.Push(AAVM_VENV->GetVariable(AAVM_GetArgument(0)));
			AAVM_OPI++;
			break;
		}
		case AAByteCode::SETVAR: {
			AAVal rhs = stack.Pop();
			AAVM_VENV->SetVariable(AAVM_GetArgument(0), rhs);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::CALL: {

			int callProc = AAVM_GetArgument(0);
			int argCount = AAVM_GetArgument(1);

			if (callProc == -1) {
				AAVM_ThrowRuntimeErr("FatalCompileError", "Call index " + std::to_string(callProc) + " is out of range!");
			}

			aa::stack<AAVal> args;
			for (int i = 0; i < argCount; i++) {
				args.Push(stack.Pop());
			}

			AAVM_OPI++;
			callstack.Push(execp);

			AAVM_VENV = procedure[callProc].venv->CloneSelf();
			AAVM_PROC = callProc;
			AAVM_OPI = 0;

			while (args.Size() > 0) {
				stack.Push(args.Pop());
			}

			break;
		}
		case AAByteCode::VMCALL: {
			
			// Get function
			int callProc = AAVM_GetArgument(0);
			int argCount = AAVM_GetArgument(1);
			
			// Collect arguments
			aa::stack<AAVal> args;
			for (int i = 0; i < argCount; i++) {
				args.Push(stack.Pop());
			}

			// Call the native function (The native function is also responsible for handling the return
			this->m_cppfunctions.Apply(callProc).fPtr(this, args, stack);

			// Did the call cause a runtime error?
			if (this->m_hasRuntimeError) {
				
				// Update runtime environment
				m_lastRuntimeError.errEnv = execp;

				// Update callstack
				m_lastRuntimeError.callStack = callstack;

				// Write error
				this->WriteRuntimeError(m_lastRuntimeError); 
				
				// Stop execution
				return AAVal::Null;

			}

			// Goto next cmd
			AAVM_OPI++;

			break;
		}
		case AAByteCode::RET: {
			int retCount = AAVM_GetArgument(0);
			aa::stack<AAVal> returnValues;
			for (int i = 0; i < retCount; i++) {
				returnValues.Push(stack.Pop());
			}

			if (callstack.Size() > 0) {
				delete execp.venv;
				execp = callstack.Pop();
			} else {
				AAVM_ThrowRuntimeErr("CallstackCorrupted", std::string("The callstack was unexpectedly corrupted"));
			}

			for (int i = 0; i < retCount; i++) {
				stack.Push(returnValues.Pop());
			}

			break;
		}
		case AAByteCode::JMPF: {
			if (stack.Pop().litVal.lit.b.val) {
				AAVM_OPI++;
			} else {
				AAVM_OPI += 1 + AAVM_GetArgument(0); // jump to next (if-else or else) or next statement after block
			}
			break;
		}
		case AAByteCode::JMPT: {
			if (!stack.Pop().litVal.lit.b.val) {
				AAVM_OPI++;
			} else {
				AAVM_OPI += 1 + AAVM_GetArgument(0); // jump to next (if-else or else) or next statement after block
			}
			break;
		}
		case AAByteCode::JMP: {
			AAVM_OPI += 1 + AAVM_GetArgument(0);
			break;
		}
		case AAByteCode::HALLOC: {
			int allocsz = AAVM_GetArgument(0);
			AAVal allocobj = AAVal(m_heapMemory->Alloc(allocsz));
			stack.Push(allocobj);
			AAVM_OPI++;
			break;
		}
		case AAByteCode::GETFIELD: {
			AAVal oPtr = stack.Pop();
			AAObject* o = m_heapMemory->operator[](oPtr.ptr);
			if (o) {
				stack.Push(o->values[AAVM_GetArgument(0)]);
			} else {
				AAVM_ThrowRuntimeErr("NullPointerException", "Null value at address '" + std::to_string(oPtr.ptr.val) + "'");
			}
			AAVM_OPI++;
			break;
		}
		case AAByteCode::SETFIELD: {
			AAVal rhs = stack.Pop();
			AAVal oPtr = stack.Pop();
			AAObject* o = m_heapMemory->operator[](oPtr.ptr);
			if (o) {
				o->values[AAVM_GetArgument(0)] = rhs;
			} else {
				AAVM_ThrowRuntimeErr("NullPointerException", "Null value at address '" + std::to_string(oPtr.ptr.val) + "'");
			}
			AAVM_OPI++;
			break;
		}
		case AAByteCode::GETELEM: {
			int i = stack.Pop().litVal.lit.i.val; // index
			AAVal arrayPtr = stack.Pop(); // Ptr to array
			AAObject* arrObj = m_heapMemory->operator[](arrayPtr.ptr); // Actual array object
			if (arrObj) {
				if (i >= 0 && i < arrObj->valCount) {
					stack.Push(arrObj->values[i]);
				} else {
					AAVM_ThrowRuntimeErr("IndexOutOfRange", "Index " + std::to_string(i) + " is out of range!");
				}
			} else {
				AAVM_ThrowRuntimeErr("NullPointerException", "Null value at address '" + std::to_string(arrayPtr.ptr.val) + "'");
			}
			AAVM_OPI++;
			break;
		}
		case AAByteCode::SETELEM: {
			AAVal v = stack.Pop(); // Value to set (RHS)
			int i = stack.Pop().litVal.lit.i.val; // index
			AAVal arrayPtr = stack.Pop(); // Ptr to array
			AAObject* arrObj = m_heapMemory->operator[](arrayPtr.ptr); // Actual array object
			if (arrObj) {
				if (i >= 0 && i < arrObj->valCount) {
					arrObj->values[i] = v;
				} else {
					AAVM_ThrowRuntimeErr("IndexOutOfRange", "Index " + std::to_string(i) + " is out of range!");
				}
			} else {
				AAVM_ThrowRuntimeErr("NullPointerException", "Null value at address '" + std::to_string(arrayPtr.ptr.val) + "'");
			}
			AAVM_OPI++;
			break;
		}
		case AAByteCode::POP:
			if (stack.Size() > 0) {
				stack.Pop();
			}
			AAVM_OPI++;
			break;
		case AAByteCode::NOP:
		default:
			AAVM_OPI++;
			break;
		}

	}

	// Release all allocated memory (No longer used)
	m_heapMemory->Release();

	// Return whatever's on top of the stack
	return this->ReportStack(stack);

}

AAVal AAVM::BinaryOperation(AAByteCode op, AA_Literal lhs, AA_Literal rhs) {
	switch (op) {
	case AAByteCode::ADD: {
		return lhs + rhs;
	}
	case AAByteCode::SUB: {
		return lhs - rhs;
	}
	case AAByteCode::MUL: {
		return lhs * rhs;
	}
	case AAByteCode::DIV: {
		return lhs / rhs;
	}
	case AAByteCode::MOD: {
		return lhs % rhs;
	}
	case AAByteCode::CMPE: {
		return AAVal(lhs == rhs);
	}
	case AAByteCode::CMPNE: {
		return AAVal(lhs != rhs);
	}
	case AAByteCode::LE: {
		return AAVal(lhs < rhs);
	}
	case AAByteCode::LEQ: {
		return AAVal(lhs <= rhs);
	}
	case AAByteCode::GE: {
		return AAVal(lhs > rhs);
	}
	case AAByteCode::GEQ: {
		return AAVal(lhs >= rhs);
	}
	default:
		return AAVal(0);
	}
}

AAVal AAVM::ReportStack(aa::stack<AAVal> stack) {

	if (stack.Size() == 1) {
		AAVal v = stack.Pop();
		if (m_outStream && m_logTopOfStackAfterExec) {
			std::wstring ws = v.ToString();
			m_outStream->write(string_cast(ws).c_str(), ws.length());
			m_outStream->write("\n", 1);
		}
		return v;
	} else {
		if (stack.Size() > 1) {
			const char* msg = "<Warning!> More than one element remained on the stack!\n";
			m_outStream->write(msg, strlen(msg));
		}
		return AAVal::Null;
	}

}

void AAVM::WriteCompilerError(AAC_CompileErrorMessage errMsg) {

	// Do we have a valid message?
	if (errMsg.errorMsg) {

		// Format the compile error message
		std::string compileErrMsg = "Failed to compile, [C" + std::to_string(errMsg.errorType) + "] -> '" + std::string(errMsg.errorMsg)
			+ "' on line " + std::to_string(errMsg.errorSource.line) + ", column " + std::to_string(errMsg.errorSource.column) + "\n";

		// Write error message
		this->WriteMsg(compileErrMsg.c_str());

	}

	// Update result
	this->m_lastCompileResult.success = false;
	this->m_lastCompileResult.firstMsg = errMsg;

}

void AAVM::WriteSyntaxError(AAP_SyntaxErrorMessage errMsg) {

	// Do we have a valid message?
	if (errMsg.errorMsg) {

		// Format the syntax error message
		std::string syntaxErrMsg = "Syntax error, [S" + std::to_string(errMsg.errorType) + "] -> '" + std::string(errMsg.errorMsg)
			+ "' on line " + std::to_string(errMsg.errorSource.line) + ", column " + std::to_string(errMsg.errorSource.column) + "\n";

		// Write syntax message
		this->WriteMsg(syntaxErrMsg.c_str());

	}

}

void AAVM::WriteRuntimeError(AAVM_RuntimeError err) {

	// Make sure there's a valid error message
	if (err.errMsg) {

		// Format runtime message
		std::string runtimeErrMsg = "Runtime exception, [" + std::string(err.errName) + "] -> '" + std::string(err.errMsg) + "'\n";

		// Write message
		this->WriteMsg(runtimeErrMsg.c_str());

	}

	// Update runtime error flag
	m_hasRuntimeError = true;

	// Set last runtime error
	m_lastRuntimeError = err;

}

void AAVM::ThrowExternalError(AAVM_RuntimeError externalErr) {

	// Set the runtime error flag
	this->m_hasRuntimeError = true;

	// Update last runtime error
	this->m_lastRuntimeError = externalErr;

}

void AAVM::WriteMsg(const char* msg) {

	// Make sure there's a valid stream to write to
	if (m_outStream) {

		// Write error message
		m_outStream->write(msg, strlen(msg));

	}

}

int AAVM::RegisterFunction(AACSingleFunction funcPtr) {
	return this->RegisterFunction(funcPtr, NULL);
}

int AAVM::RegisterFunction(AACSingleFunction funcPtr, AACNamespace* domain) {
	AAFuncSignature* dcSig;
	return this->RegisterFunction(funcPtr, dcSig, domain);
}

int AAVM::RegisterFunction(AACSingleFunction funcPtr, AAFuncSignature*& funcSig, AACNamespace* domain, bool isClassMethod) {

	// Create the new function signature
	funcSig = new AAFuncSignature;

	// Is it a new function?
	bool isNewFunction = false;

	int procID = 0;
	if (!m_cppfunctions.FindFirstIndex([funcPtr](AACSingleFunction& func) { return func.equals(funcPtr); }, procID)) {

		// Fetch next proc ID
		procID = (int)m_cppfunctions.Size();
		isNewFunction = true;

	}

	// Create function signature
	funcSig->name = funcPtr.name;
	funcSig->returnType = funcPtr.returnType;
	funcSig->parameters = funcPtr.params;
	funcSig->isVMFunc = true;
	funcSig->isClassMethod = isClassMethod;
	funcSig->accessModifier = AAAccessModifier::PUBLIC;
	funcSig->procID = procID;

	// Add only if new function
	if (isNewFunction) {

		// Push functions
		m_cppfunctions.Add(funcPtr);

	}

	// Do we have a domain to add this function to?
	if (domain) {

		// Add to domain
		domain->AddFunction(funcSig);

	} else {

		// Add VM function so the compiler can recognize it
		m_compiler->AddVMFunction(funcSig);

	}

	// Return the proc ID
	return procID;

}

AAClassSignature* AAVM::RegisterClass(std::wstring typeName, AACClass cClass) {

	// Is string defined?
	if (AACTypeDef::String != 0) {

		bool any = true;

		for (auto& method : cClass.classMethods) {
			if (method.name == L"ToString" && method.params.size() == 0) {
				any = false;
			}
		}

		if (any) {
			cClass.classMethods.push_back(AACSingleFunction(L"ToString", &AAO_ToString, AACTypeDef::String, 0));
		}
		
	}

	// Class signature
	AAClassSignature* cc = new AAClassSignature(typeName);

	// For each class method
	for (auto& func : cClass.classMethods) {

		// Check if it's a constructor
		bool isCtor = func.name == L".ctor";
		bool isDtor = func.name == L".dtor";

		// Not the constructor
		if (!isCtor && !isDtor) {

			// Update function name
			func.name = cc->name + L"::" + func.name;

		} else {

			// Update constructor name
			func.name = cc->name + L"::" + cc->name;

		}

		// Function signature
		AAFuncSignature* sig;

		// Because it's a class method we always push the 'this' identifier -> Note, should not be the case if static (but not implemented yet)
		func.params.insert(func.params.begin(), AAFuncParam(cc->type, L"this"));

		// Register the funcion and get the VMCall procID
		this->RegisterFunction(func, sig, cClass.domain, true);
		sig->isClassCtor = isCtor;
		sig->isClassDtor = isDtor;

		// Add method to class
		cc->methods.Add(sig);

	}

	// For each operator overload
	for (auto& op : cClass.classOperators) {

		// Get the actual function
		AACSingleFunction func = op.funcPtr;

		// Update function name
		func.name = cc->name + L"::" + func.name;

		// Function signature
		AAFuncSignature* sig;

		// Because it's a class method we always push the 'this' identifier -> Note, should not be the case if static (but not implemented yet)
		func.params.insert(func.params.begin(), AAFuncParam(cc->type, L"this"));

		// Register the funcion and get the VMCall procID
		int procID = this->RegisterFunction(func, sig, cClass.domain, true);

		// Add method to operators list
		cc->operators.Add(AAClassOperatorSignature(op.operatorToOverride, sig));

	}

	// For each class field
	for (auto& field : cClass.classFields) {

		AAClassFieldSignature ccf;
		ccf.fieldID = (int)cc->fields.Size();
		ccf.accessModifier = AAAccessModifier::PUBLIC;
		ccf.type = field.fieldtype;
		ccf.name = field.fieldname;

		cc->fields.Add(ccf);

	}

	// Update class size
	cc->classByteSz = m_compiler->GetClassCompilerInstance()->CalculateMemoryUse(cc);

	// Fix all references to ourselves
	this->FixSelfReferences(cc);

	// Do we have domain to work with?
	if (cClass.domain) {
		
		// Add class to domain
		cClass.domain->AddClass(cc);

	} else {

		// Add the VM class
		m_compiler->AddVMClass(cc);

	}

	// Return the class signature
	return cc;

}

void AAVM::LoadStandardLibrary() {

	// Register println
	this->RegisterFunction(AACSingleFunction(L"println", &AAConsole_PrintLn, AACType::Void, 1, AAFuncParam(AACType::Any, L"obj")));

	// Create string class
	AACClass stringClass;
	stringClass.classMethods.push_back(AACSingleFunction(L"length", &AAString_Length, AACTypeDef::Int32, 0));
	stringClass.classOperators.push_back(AACClassOperator(L"+", AACSingleFunction(L"concat", &AAString_Concat, AACType::ExportReferenceType, 1, AAFuncParam(AACType::ExportReferenceType, L"_x"))));

	// Register string class and type
	AAClassSignature* strCls = this->RegisterClass(L"string", stringClass);
	AACTypeDef::String = strCls->type;

	// Create object class
	AACClass objectClass;
	objectClass.classMethods.push_back(AACSingleFunction(L".ctor", &AAO_NewObject, AACType::ExportReferenceType, 0));
	this->RegisterClass(L"object", objectClass); // IDEA: Rename to Any

	// Create standard namespaces
	AACNamespace* __std = new AACNamespace(L"std", NULL);
	AACNamespace* __stdio = new AACNamespace(L"io", __std);

	// Create filestream class
	AACClass stdio_filestream;
	stdio_filestream.domain = __stdio;
	stdio_filestream.classMethods.push_back(AACSingleFunction(L".ctor", &AAFileStream_Open, AACType::ExportReferenceType, 1, AAFuncParam(AACTypeDef::String, L"_filepath")));
	stdio_filestream.classMethods.push_back(AACSingleFunction(L"close", &AAFileStream_Close, AACType::Void, 0));
	stdio_filestream.classOperators.push_back(AACClassOperator(L"<<", AACSingleFunction(L"writetofile", &AAFileStream_Write, AACType::ExportReferenceType, 1, AAFuncParam(AACType::Any, L"_content"))));
	stdio_filestream.classFields.push_back(AACClassField(AACTypeDef::Int32, L"_selfptr"));

	// Register the filestream class
	this->RegisterClass(L"FileStream", stdio_filestream);

	// Add more classes here

	// Register std::io in std
	__std->childspaces.Add(__stdio);

	// Add namespace
	this->m_compiler->AddVMNamespace(__std);

}

void AAVM::FixSelfReferences(AAClassSignature* signature) {

	// Fix all method references
	signature->methods.ForEach(
		[signature]( AAFuncSignature*& sig ) {
			if (sig->returnType == AACType::ExportReferenceType) {
				sig->returnType = signature->type;
			}
			for (auto& param : sig->parameters) {
				if (param.type == AACType::ExportReferenceType) {
					param.type = signature->type;
				}
			}
		}
	);

	// Fix all field references
	signature->fields.ForEach(
		[signature](AAClassFieldSignature& field) {
			if (field.type == AACType::ExportReferenceType) {
				field.type = signature->type;
			}
		}
	);

	// Fix all operator references
	signature->operators.ForEach(
		[signature](AAClassOperatorSignature& op) {
			if (op.method->returnType == AACType::ExportReferenceType) {
				op.method->returnType = signature->type;
			}
			for (auto& param : op.method->parameters) {
				if (param.type == AACType::ExportReferenceType) {
					param.type = signature->type;
				}
			}
		}
	);

}

void AAVM::StopAndLogCompile() {

	// If we should log stuff, we do it now
	if (m_logCompileMessages) {
		printf("Compile time: %fs\n", (float)(clock() - m_startCompile) / CLOCKS_PER_SEC);
	}

}
